<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Hash Text Console</title>
    <link rel="stylesheet" href="../styles/styles.css" />
    <style>
      :root {
        color-scheme: light dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #0f172a;
        color: #e2e8f0;
        margin: 0;
        height: auto;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        overflow-y: auto;
        padding: 48px 16px;
      }

      main {
        width: min(1040px, 100%);
        backdrop-filter: blur(16px);
        background: rgba(15, 23, 42, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 24px;
        padding: 32px;
        box-shadow: 0 32px 64px -40px rgba(15, 23, 42, 0.9);
        display: flex;
        flex-direction: column;
        gap: 32px;
      }

      header {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(15, 23, 42, 0.88);
        border-radius: 16px;
      }

      header h1 {
        display: flex;
        align-items: center;
        gap: 12px;
        margin: 0;
        font-size: 2rem;
        letter-spacing: -0.02em;
      }

      header h1 span {
        font-size: 0.9rem;
        font-weight: 500;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(14, 165, 233, 0.15);
        color: #38bdf8;
      }

      header p.lead {
        margin: 6px 0 0;
        color: #94a3b8;
        font-size: 0.95rem;
        max-width: 72ch;
      }

      section.card {
        background: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 20px;
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      section.card h2 {
        margin: 0;
        font-size: 1.2rem;
        letter-spacing: -0.01em;
      }

      .field-group {
        display: grid;
        gap: 12px;
      }

      label {
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.14em;
        color: #64748b;
      }

      input[type="text"],
      input[type="number"],
      textarea {
        background: rgba(15, 23, 42, 0.92);
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.3);
        color: #f1f5f9;
        font-size: 0.95rem;
        padding: 12px 16px;
        transition: border 0.2s ease, box-shadow 0.2s ease;
      }

      .field-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
      }

      label.checkbox-label {
        text-transform: none;
        letter-spacing: normal;
        font-size: 0.95rem;
        color: #e2e8f0;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      label.checkbox-label input[type="checkbox"] {
        width: 18px;
        height: 18px;
        accent-color: #38bdf8;
      }

      textarea {
        resize: vertical;
      }

      input[type="text"]:focus,
      textarea:focus {
        outline: none;
        border-color: rgba(56, 189, 248, 0.7);
        box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.25);
      }

      .button-row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      button {
        border: none;
        border-radius: 12px;
        font-size: 0.95rem;
        font-weight: 600;
        padding: 12px 20px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
      }

      button.primary {
        background: linear-gradient(120deg, #0ea5e9, #2563eb);
        color: #f8fafc;
        box-shadow: 0 12px 24px -12px rgba(37, 99, 235, 0.65);
      }

      button.secondary {
        background: rgba(148, 163, 184, 0.18);
        color: #e2e8f0;
      }

      button:disabled {
        opacity: 0.6;
        cursor: wait;
        box-shadow: none;
      }

      button:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 28px -16px rgba(14, 165, 233, 0.85);
      }

      .status-chip {
        align-self: flex-start;
        padding: 8px 14px;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
        background: rgba(148, 163, 184, 0.16);
        color: #cbd5f5;
      }

      .status-chip[data-level="success"] {
        background: rgba(34, 197, 94, 0.16);
        color: #4ade80;
      }

      .status-chip[data-level="error"] {
        background: rgba(248, 113, 113, 0.18);
        color: #f87171;
      }

      .status-chip[data-level="info"] {
        background: rgba(56, 189, 248, 0.15);
        color: #38bdf8;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 16px;
      }

      .panel {
        border: 1px solid rgba(148, 163, 184, 0.15);
        border-radius: 16px;
        padding: 16px;
        background: rgba(15, 23, 42, 0.6);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .panel h3 {
        margin: 0;
        font-size: 1rem;
        color: #cbd5f5;
      }

      pre {
        background: rgba(15, 23, 42, 0.9);
        border-radius: 12px;
        padding: 16px;
        margin: 0;
        max-height: 260px;
        overflow: auto;
        font-size: 0.85rem;
        line-height: 1.5;
        border: 1px solid rgba(148, 163, 184, 0.12);
        color: #e2e8f0;
      }

      .log-area {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 240px;
        overflow-y: auto;
        border-radius: 12px;
      }

      .log-entry {
        padding: 12px 14px;
        border-radius: 10px;
        font-size: 0.9rem;
        background: rgba(148, 163, 184, 0.12);
        border: 1px solid rgba(148, 163, 184, 0.2);
      }

      .log-entry--success {
        background: rgba(34, 197, 94, 0.12);
        border-color: rgba(34, 197, 94, 0.28);
        color: #4ade80;
      }

      .log-entry--error {
        background: rgba(248, 113, 113, 0.12);
        border-color: rgba(248, 113, 113, 0.28);
        color: #fca5a5;
      }

      .helper-text {
        font-size: 0.85rem;
        color: #64748b;
      }

      @media (max-width: 720px) {
        body {
          padding: 24px 12px;
        }

        main {
          padding: 24px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1>
          Hash Text Console
          <span>Live</span>
          <span id="topHealthStatus" class="status-chip" data-level="info">Awaiting health check…</span>
        </h1>
        <p class="lead">
          Minimal harness for validating Gemini models routed exclusively through Cloudflare AI Gateway. Configure the backend
          and send sample hash payloads directly to the gateway-backed text agent.
        </p>
      </header>

      <section class="card">
        <h2>Server Health</h2>
        <div class="field-group">
          <label for="backendBaseUrl">Backend Base URL</label>
          <input id="backendBaseUrl" type="text" placeholder="http://localhost:3000" spellcheck="false" />
        </div>
        <div class="button-row">
          <button id="healthCheckButton" class="secondary" type="button">Check Health</button>
          <button id="pingButton" class="secondary" type="button">Ping x5</button>
        </div>
        <div id="healthStatus" class="status-chip" data-level="info">Awaiting health check…</div>
        <div id="pingStatus" class="helper-text">No ping yet.</div>
      </section>

      <section class="card">
        <h2>StoryDefinition (from Prompt)</h2>
        <div class="field-group">
          <div class="field-row">
            <div>
              <label for="sdLength">Length</label>
              <select id="sdLength">
                <option value="small">small</option>
                <option value="medium" selected>medium</option>
                <option value="long">long</option>
              </select>
            </div>
            <div>
              <label for="sdDensity">Density</label>
              <select id="sdDensity">
                <option value="short">short</option>
                <option value="medium" selected>medium</option>
                <option value="dense">dense</option>
              </select>
            </div>
          </div>
        </div>
        <div class="field-group">
          <label for="sdPrompt">Concept / Prompt for StoryDefinition</label>
          <textarea
            id="sdPrompt"
            rows="5"
            spellcheck="false"
            placeholder="A cozy mystery in a seaside town about a retired chef who solves a peculiar disappearance during the annual chowder festival."
          ></textarea>
        </div>
        <div class="button-row">
          <button id="sdDefineButton" class="primary" type="button">Generate StoryDefinition (/api/story/define)</button>
        </div>
        <div class="panel">
          <h3>Definition JSON</h3>
          <div id="sdDefineStatus" class="helper-text">Awaiting request…</div>
          <pre id="sdDefinitionOut">—</pre>
        </div>
      </section>

      <section class="card">
        <h2>Storyline Generator (Manual JSON)</h2>
        <div class="field-group">
          <label for="sdDefinitionJson">StoryDefinition JSON</label>
          <textarea
            id="sdDefinitionJson"
            rows="12"
            spellcheck="false"
            placeholder='Paste a StoryDefinition object matching frontend/src/types.ts'
          ></textarea>
        </div>
        <div class="field-group">
          <label for="sdPreviousOptionJson">Optional Previous Option (OptionObject JSON)</label>
          <textarea
            id="sdPreviousOptionJson"
            rows="8"
            spellcheck="false"
            placeholder='{"id":"opt-1","text":"Investigate the pier","action":{"type":"goToNextPage"}}'
          ></textarea>
          <p class="helper-text">Leave empty for first page. Use an option from a previous page response.</p>
        </div>
        <div class="field-row">
          <div>
            <label for="sdStepIndex">Page Index</label>
            <input id="sdStepIndex" type="number" min="0" step="1" value="0" />
          </div>
        </div>
        <div class="button-row">
          <button id="sdGenerateButton" class="primary" type="button">Generate Page (/api/story/step)</button>
        </div>
        <div class="panel">
          <h3>Page JSON</h3>
          <div id="sdPageStatus" class="helper-text">Awaiting request…</div>
          <pre id="sdPageJson">—</pre>
        </div>
        <div class="panel">
          <h3>Rendered Page</h3>
          <div id="sdRenderedPage" class="log-area"></div>
        </div>
      </section>
      
      <section class="card">
        <h2>Back Cover Summary (LLM)</h2>
        <div class="field-group">
          <label for="sumDefinitionJson">StoryDefinition JSON</label>
          <textarea
            id="sumDefinitionJson"
            rows="8"
            spellcheck="false"
            placeholder='Paste a StoryDefinition object (or use the one above)'
          ></textarea>
          <p class="helper-text">If empty, will attempt to reuse the definition from the section above.</p>
        </div>
        <div class="field-group">
          <label for="sumPagesJson">Optional Pages (StoryPage[] JSON, only id + text used)</label>
          <textarea
            id="sumPagesJson"
            rows="6"
            spellcheck="false"
            placeholder='[{"id":"p1","text":"Opening scene..."},{"id":"p2","text":"Conflict rises..."}]'
          ></textarea>
        </div>
        <div class="button-row">
          <button id="sumGenerateButton" class="primary" type="button">Generate Back Cover Summary (/api/story/summary)</button>
        </div>
        <div class="panel">
          <h3>Summary JSON</h3>
          <div id="sumStatus" class="helper-text">Awaiting request…</div>
          <pre id="sumOut">—</pre>
        </div>
      </section>

      <section class="card">
        <h2>Gemini Images (Direct) Playground</h2>
        <div class="field-group">
          <label for="imagePromptInput">Image Prompt</label>
          <input id="imagePromptInput" type="text" placeholder="A cozy watercolor cottage in a misty forest at sunrise" spellcheck="false" />
          <p class="helper-text">
            This calls the backend route that uses the Gemini Images API directly (no Cloudflare). Default model: gemini-2.5-flash-image (Nano Banana).
          </p>
        </div>
        <div class="button-row">
          <button id="runImageAgentButton" class="primary" type="button">Generate Image (/api/agents/image/generate)</button>
        </div>
        <div class="grid">
          <div class="panel">
            <h3>Image Agent</h3>
            <div id="imageAgentRequestMeta" class="helper-text">POST —</div>
            <pre id="imageAgentRequestBody">—</pre>
            <div id="imageAgentResponseMeta" class="helper-text">Awaiting request…</div>
            <pre id="imageAgentResponseBody"></pre>
          </div>
          <div class="panel">
            <h3>Preview</h3>
            <img id="imagePreview" alt="Generated preview" style="max-width: 100%; border-radius: 12px; border: 1px solid rgba(148,163,184,0.18);" />
            <div class="helper-text">The generated image will appear here.</div>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>Speech (ElevenLabs via Cloudflare Gateway)</h2>
        <div class="field-group">
          <label for="speechTextTextarea">Text to Speak</label>
          <textarea
            id="speechTextTextarea"
            rows="4"
            spellcheck="false"
            placeholder="Read a short excerpt from the current story page."
          ></textarea>
        </div>
        <div class="field-row">
          <div>
            <label for="speechGenreSelect">Genre (optional)</label>
            <select id="speechGenreSelect">
              <option value="">(auto/default)</option>
              <option value="adventure">adventure</option>
              <option value="fantasy">fantasy</option>
              <option value="scifi">scifi</option>
              <option value="horror">horror</option>
              <option value="mystery">mystery</option>
              <option value="romance">romance</option>
              <option value="comedy">comedy</option>
              <option value="drama">drama</option>
              <option value="action">action</option>
              <option value="historical">historical</option>
            </select>
          </div>
        </div>
        <div class="button-row">
          <button id="runSpeechButton" class="primary" type="button">Generate Speech (/api/speech/generate)</button>
        </div>
        <div class="panel">
          <h3>Speech Status</h3>
          <div id="speechStatus" class="helper-text">Awaiting request…</div>
          <audio id="speechAudio" controls style="width: 100%;"></audio>
        </div>
      </section>

      <section class="card">
        <h2>Execution Log</h2>
        <div id="logArea" class="log-area"></div>
      </section>
    </main>

    <script>
      (function () {
        const byId = (id) => document.getElementById(id);
        const getBase = () => {
          const el = byId("backendBaseUrl");
          const v = (el && el.value || "").trim();
          return v.length ? v.replace(/\/$/, "") : "http://localhost:3000";
        };
        const postJson = async (url, data) => {
          const res = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });
          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            throw new Error(err.error || ("Request failed: " + res.status));
          }
          return await res.json();
        };

        // Health check
        byId("healthCheckButton").addEventListener("click", async () => {
          const base = getBase();
          const status = byId("healthStatus");
          status.textContent = "Checking…";
          status.setAttribute("data-level", "info");
          try {
            const res = await fetch(`${base}/api/text/generate`, { method: "GET" });
            if (!res.ok) throw new Error("HTTP " + res.status);
            const body = await res.json().catch(() => ({}));
            const isOk = body && (body.health === "ok" || body.status === "ok");
            if (isOk) {
              const model = body?.env?.modelId ? ` model=${body.env.modelId}` : "";
              status.textContent = "Server OK" + model;
              status.setAttribute("data-level", "success");
            } else {
              status.textContent = "Unexpected response";
              status.setAttribute("data-level", "error");
            }
          } catch (e) {
            status.textContent = "Error: " + (e && e.message ? e.message : String(e));
            status.setAttribute("data-level", "error");
          }
        });

        // Ping x5 to assess connection quality
        byId("pingButton").addEventListener("click", async () => {
          const base = getBase();
          const out = byId("pingStatus");
          out.textContent = "Pinging…";
          const samples = 5;
          const times = [];
          let ok = 0;
          for (let i = 0; i < samples; i++) {
            const t0 = performance.now();
            try {
              const res = await fetch(`${base}/`, { method: "GET", cache: "no-store" });
              if (!res.ok) throw new Error("HTTP " + res.status);
              await res.json().catch(() => ({}));
              const dt = performance.now() - t0;
              times.push(dt);
              ok++;
            } catch {
              times.push(NaN);
            }
          }
          const valid = times.filter((t) => Number.isFinite(t));
          if (valid.length === 0) {
            out.textContent = "Ping failed (no successful responses).";
            return;
          }
          const min = Math.min(...valid);
          const max = Math.max(...valid);
          const avg = valid.reduce((a, b) => a + b, 0) / valid.length;
          const fmt = (n) => Math.round(n);
          out.textContent = `Ping: ${ok}/${samples} ok — min ${fmt(min)}ms / avg ${fmt(avg)}ms / max ${fmt(max)}ms`;
        });

        function renderPage(page) {
          const container = byId("sdRenderedPage");
          container.innerHTML = "";
          const card = document.createElement("div");
          card.className = "panel";

          const text = document.createElement("div");
          text.textContent = page.text || "";
          card.appendChild(text);

          if (page.image && (page.image.alt || page.image.prompt)) {
            const imgMeta = document.createElement("div");
            imgMeta.className = "helper-text";
            imgMeta.textContent = "image.alt: " + (page.image.alt || "") + " | prompt: " + (page.image.prompt || "");
            card.appendChild(imgMeta);
          }

          const optsWrap = document.createElement("div");
          optsWrap.style.display = "grid";
          optsWrap.style.gap = "8px";
          for (const opt of page.options || []) {
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.alignItems = "flex-start";

            const chip = document.createElement("span");
            chip.className = "status-chip";
            chip.textContent = opt.action && opt.action.type ? String(opt.action.type) : "option";
            chip.setAttribute("data-level", "info");

            const block = document.createElement("div");
            block.style.display = "grid";
            block.style.gap = "6px";

            const topLine = document.createElement("div");
            topLine.style.display = "flex";
            topLine.style.gap = "8px";
            topLine.style.alignItems = "center";

            const label = document.createElement("span");
            label.textContent = opt.text || "(option)";

            const useBtn = document.createElement("button");
            useBtn.className = "secondary";
            useBtn.type = "button";
            useBtn.textContent = "Use as previousOption";
            useBtn.onclick = () => {
              try {
                byId("sdPreviousOptionJson").value = JSON.stringify(opt, null, 2);
                byId("sdPreviousOptionJson").scrollIntoView({ behavior: "smooth", block: "center" });
              } catch {
                byId("sdPreviousOptionJson").value = "";
              }
            };

            topLine.appendChild(label);
            topLine.appendChild(useBtn);
            block.appendChild(topLine);

            // Nested branch rendering
            if (opt.action && opt.action.type === "branch" && Array.isArray(opt.action.options)) {
              const branchText = document.createElement("div");
              branchText.className = "helper-text";
              branchText.textContent = opt.action.text ? String(opt.action.text) : "(branch)";
              block.appendChild(branchText);

              const nested = document.createElement("div");
              nested.style.display = "grid";
              nested.style.gap = "6px";
              nested.style.paddingLeft = "12px";
              for (const sub of opt.action.options) {
                const subRow = document.createElement("div");
                subRow.style.display = "flex";
                subRow.style.gap = "8px";
                subRow.style.alignItems = "center";

                const subChip = document.createElement("span");
                subChip.className = "status-chip";
                subChip.textContent = sub.action && sub.action.type ? String(sub.action.type) : "option";
                subChip.setAttribute("data-level", "info");

                const subLabel = document.createElement("span");
                subLabel.textContent = sub.text || "(option)";

                const subUse = document.createElement("button");
                subUse.className = "secondary";
                subUse.type = "button";
                subUse.textContent = "Use nested option";
                subUse.onclick = () => {
                  try {
                    byId("sdPreviousOptionJson").value = JSON.stringify(sub, null, 2);
                    byId("sdPreviousOptionJson").scrollIntoView({ behavior: "smooth", block: "center" });
                  } catch {
                    byId("sdPreviousOptionJson").value = "";
                  }
                };

                subRow.appendChild(subChip);
                subRow.appendChild(subLabel);
                subRow.appendChild(subUse);
                nested.appendChild(subRow);
              }
              block.appendChild(nested);
            }

            row.appendChild(chip);
            row.appendChild(block);
            optsWrap.appendChild(row);
          }
          card.appendChild(optsWrap);
          container.appendChild(card);
        }

        // Generate StoryDefinition from prompt
        byId("sdDefineButton").addEventListener("click", async () => {
          const base = getBase();
          const status = byId("sdDefineStatus");
          const pre = byId("sdDefinitionOut");
          status.textContent = "Generating definition…";
          try {
            const length = byId("sdLength").value;
            const density = byId("sdDensity").value;
            const description = byId("sdPrompt").value.trim();
            const def = await postJson(`${base}/api/story/define`, { length, density, description });
            pre.textContent = JSON.stringify(def, null, 2);
            status.textContent = "OK";
            // Auto-fill the JSON textarea for storyline generation
            byId("sdDefinitionJson").value = JSON.stringify(def, null, 2);
          } catch (e) {
            status.textContent = "Error: " + (e && e.message ? e.message : String(e));
          }
        });

        byId("sdGenerateButton").addEventListener("click", async () => {
          const base = getBase();
          const status = byId("sdPageStatus");
          const pre = byId("sdPageJson");
          status.textContent = "Generating page…";
          try {
            const raw = byId("sdDefinitionJson").value;
            const stepIndexRaw = byId("sdStepIndex").value;
            const parsed = JSON.parse(raw);
            let stepIndex = Number.parseInt(String(stepIndexRaw), 10);
            if (!Number.isInteger(stepIndex) || stepIndex < 0) stepIndex = 0;
            const payload = { definition: parsed, stepIndex };
            const prevRaw = (byId("sdPreviousOptionJson").value || "").trim();
            if (prevRaw.length > 0) {
              try {
                const prevObj = JSON.parse(prevRaw);
                // basic shape check
                if (typeof prevObj !== "object" || prevObj === null) {
                  throw new Error("Invalid previousOption");
                }
                payload["previousOption"] = prevObj;
              } catch (e) {
                status.textContent = "Error: invalid previousOption JSON";
                return;
              }
            }
            const page = await postJson(`${base}/api/story/step`, payload);
            pre.textContent = JSON.stringify(page, null, 2);
            status.textContent = "OK";
            renderPage(page);
          } catch (e) {
            status.textContent = "Error: " + (e && e.message ? e.message : String(e));
          }
        });

        // Generate Back Cover Summary
        byId("sumGenerateButton").addEventListener("click", async () => {
          const base = getBase();
          const status = byId("sumStatus");
          const out = byId("sumOut");
          status.textContent = "Generating summary…";
          try {
            let defText = (byId("sumDefinitionJson").value || "").trim();
            if (!defText) {
              defText = (byId("sdDefinitionJson").value || "").trim();
            }
            if (!defText) {
              status.textContent = "Error: Provide a StoryDefinition JSON.";
              return;
            }
            let definition;
            try {
              definition = JSON.parse(defText);
            } catch {
              status.textContent = "Error: Invalid StoryDefinition JSON.";
              return;
            }
            let pages = [];
            const pagesRaw = (byId("sumPagesJson").value || "").trim();
            if (pagesRaw) {
              try {
                const parsed = JSON.parse(pagesRaw);
                if (Array.isArray(parsed)) {
                  pages = parsed.map(p => ({ id: p?.id, text: p?.text })).filter(p => typeof p.id === "string" && typeof p.text === "string");
                }
              } catch {
                // ignore bad pages; continue with none
              }
            }
            const result = await postJson(`${base}/api/story/summary`, { definition, pages });
            out.textContent = JSON.stringify(result, null, 2);
            status.textContent = "OK";
          } catch (e) {
            status.textContent = "Error: " + (e && e.message ? e.message : String(e));
          }
        });

        // Speech: POST /api/speech/generate and play audio
        (function () {
          let lastObjectUrl = null;
          const cleanupUrl = () => {
            if (lastObjectUrl) {
              URL.revokeObjectURL(lastObjectUrl);
              lastObjectUrl = null;
            }
          };
          byId("runSpeechButton").addEventListener("click", async () => {
            const base = getBase();
            const btn = byId("runSpeechButton");
            const status = byId("speechStatus");
            const audioEl = byId("speechAudio");
            const text = (byId("speechTextTextarea").value || "").trim();
            const genre = (byId("speechGenreSelect").value || "").trim();
            if (!text) {
              status.textContent = "Please enter text to speak.";
              return;
            }
            btn.disabled = true;
            status.textContent = "Requesting speech…";
            cleanupUrl();
            audioEl.removeAttribute("src");
            try {
              const res = await fetch(`${base}/api/speech/generate`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(genre ? { text, genre } : { text }),
              });
              if (!res.ok) {
                const errText = await res.text().catch(() => "");
                throw new Error(errText || `HTTP ${res.status}`);
              }
              const blob = await res.blob();
              const url = URL.createObjectURL(blob);
              lastObjectUrl = url;
              audioEl.src = url;
              status.textContent = "OK — ready to play.";
              await audioEl.play().catch(() => { /* ignore autoplay blocks */ });
            } catch (e) {
              status.textContent = "Error: " + (e && e.message ? e.message : String(e));
            } finally {
              btn.disabled = false;
            }
          });
          // Revoke object URL when page unloads
          window.addEventListener("beforeunload", () => {
            try { cleanupUrl(); } catch {}
          });
        })();
      })();
    </script>
  </body>
</html>